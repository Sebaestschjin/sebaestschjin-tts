local Search = require("sebaestschjin-tts.Search")

local Utils = {}

--- Reads the body of the notebook with the given name.
---@param name string
---@return nil | string
function Utils.readNotebook(name)
    for _, notebook in pairs(Notes.getNotebookTabs()) do
        if notebook.title == name then
            return notebook.body
        end
    end
    return nil
end

---@overload fun(guid: GUID, callback: (fun(): void), timeout: number): void
---@overload fun(guid: GUID, callback: (fun(): void)): void
---@param guid GUID
---@param callback fun(): void
---@param timeout number
---@param timeoutCallback fun(): void
function Utils.waitForObject(guid, callback, timeout, timeoutCallback)
    local waiter = function()
        return getObjectFromGUID(guid) ~= nil
                and (--[[---@not nil]] getObjectFromGUID(guid)).spawning == false
    end
    Wait.condition(callback, waiter, timeout, timeoutCallback)
end

---@overload fun(zone: GUID, search: seb_Search_Full, callback: fun(): void): void
---@param zone GUID
---@param search seb_Search_Full
---@param callback fun(): void
---@param timeout number
---@param timeoutCallback fun(): void
function Utils.waitForObjectInZone(zone, search, callback, timeout, timeoutCallback)
    local waiter = function()
        local obj = Search.inZone(--[[---@type tts__ScriptingTrigger]] getObjectFromGUID(zone), search)
        return obj ~= nil and not (--[[---@type tts__Object]] obj).spawning
    end
    Wait.condition(callback, waiter, timeout, timeoutCallback)
end

---@param object tts__Object
---@param snapPoint number
---@return tts__Vector
function Utils.getSnapPosition(object, snapPoint)
    return object.positionToWorld(object.getSnapPoints()[snapPoint].position)
end

return Utils
